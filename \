pub mod fragment;
pub mod vertex;

use crate::{
    Matrix4, Rad, Vector3, Vector4, Zero,
    error::Error,
    engine::Engine,
    components::Model,
};
use std::sync::Arc;
use vulkano::{
    buffer::{cpu_pool::CpuBufferPool, BufferUsage, CpuAccessibleBuffer, TypedBufferAccess},
    command_buffer::{AutoCommandBufferBuilder, CommandBufferUsage, SubpassContents},
    descriptor_set::persistent::PersistentDescriptorSet,
    device::{physical::PhysicalDevice, Device, DeviceExtensions, Queue},
    format::Format,
    image::{
        attachment::AttachmentImage, view::ImageView, ImageUsage, SampleCount, SwapchainImage,
    },
    instance::Instance,
    pipeline::{
        shader::{GraphicsEntryPoint, ShaderModule},
        depth_stencil::DepthStencil, vertex::BuffersDefinition, viewport::Viewport,
        GraphicsPipeline, PipelineBindPoint,
    },
    render_pass::{Framebuffer, FramebufferAbstract, RenderPass, Subpass},
    swapchain::{
        self, AcquireError, ColorSpace, Surface, SurfaceTransform, Swapchain,
        SwapchainCreationError,
    },
    sync::{self, FlushError, GpuFuture, NowFuture},
    Version,
};

pub trait Shaders {
    fn update(&mut self, previous_frame_end: &mut Option<Box<NowFuture>>, recreate_swapchain: &mut bool, engine: &Engine);

    fn vertex_entry_point(&self) -> GraphicsEntryPoint;

    fn fragment_entry_point(&self) -> GraphicsEntryPoint; 
}

pub struct DefaultShaders {
    uniform_buffer: CpuBufferPool::<vertex::ty::Data>,
    frag_uniform_buffer: CpuBufferPool::<fragment::ty::Data>,
    lights_array: [fragment::ty::Light; 1024],
    pub vertex: vertex::Shader,
    pub fragment: fragment::Shader,
}

impl DefaultShaders {
    pub fn new(device: Arc<Device>) -> Result<Arc<Self>, Error> {
        Ok(Arc::new(Self {
        uniform_buffer:
            CpuBufferPool::<vertex::ty::Data>::new(device.clone(), BufferUsage::all()),
        frag_uniform_buffer:
            CpuBufferPool::<fragment::ty::Data>::new(device.clone(), BufferUsage::all()),
        lights_array: [fragment::ty::Light {
            position: Vector3::zero().into(),
            rotation: Matrix4::zero().into(),
            color: Vector4::zero().into(),
            directional: 0,
            cutoff: 0.0,
            outer_cutoff: 0.0,
            intensity: 0.0,
            attenuation: 0.0,
            _dummy0: [0; 4],
            _dummy1: [0; 12],
        }; 1024],
            vertex: vertex::Shader::load(device.clone())?,
            fragment: fragment::Shader::load(device.clone())?,
        }))
    }
}

impl Shaders for DefaultShaders {
    fn update(&mut self, previous_frame_end: &mut Option<Box<NowFuture>>, recreate_swapchain: &mut bool, engine: &Engine) {
        let mut pipeline = engine.pipeline.lock().unwrap();
        let scene = engine.scene.lock().unwrap();
        let mut builder = AutoCommandBufferBuilder::primary(
            engine.device.clone(),
            engine.queue.family(),
            CommandBufferUsage::OneTimeSubmit,
        )
        .unwrap();
        let bg: [f32; 4] = (*scene.bg.lock().unwrap()).into();
        let dimensions: [u32; 2] = engine.surface.window().inner_size().into();

        builder
            .bind_pipeline_graphics(pipeline.clone())
            .begin_render_pass(
                framebuffers[image_num].clone(),
                SubpassContents::Inline,
                vec![bg.into(), 1.0_f32.into(), [0.0_f32; 4].into()],
            )
            .unwrap();

        for entity in engine.scene.lock().unwrap().world.entities() {
            if let Some(models) = entity.get_type::<Model>(ecs::id("model")) {
                for model in &*models {
                    let uniform_buffer_subbuffer = {
                        let rotation = {
                            let rotation = model.transform.rotation.lock().unwrap();

                            Matrix4::from_angle_x(Rad(rotation.x))
                                * Matrix4::from_angle_y(Rad(rotation.y))
                                * Matrix4::from_angle_z(Rad(rotation.z))
                        };
                        let aspect_ratio = dimensions[0] as f32 / dimensions[1] as f32;
                        let camera = scene.camera.lock().unwrap();
                        let proj = cgmath::perspective(
                            Rad(*camera.fov.lock().unwrap()),
                            aspect_ratio,
                            *camera.near.lock().unwrap(),
                            *camera.far.lock().unwrap(),
                        );
                        let cam_rotation = {
                            let rotation = camera.transform.rotation.lock().unwrap();

                            Matrix4::from_angle_x(Rad(rotation.x))
                                * Matrix4::from_angle_y(Rad(rotation.y))
                                * Matrix4::from_angle_z(Rad(rotation.z))
                        };
                        let translation = Matrix4::from_translation(
                            *model.transform.position.lock().unwrap(),
                        );
                        let cam_translation = Matrix4::from_translation(
                            *camera.transform.position.lock().unwrap(),
                        );
                        let uniform_data = vertex::ty::Data {
                            proj: proj.into(),
                            scale: {
                                let scale = model.transform.scale.lock().unwrap();

                                Matrix4::from_nonuniform_scale(
                                    scale.x, scale.y, scale.z,
                                )
                            }
                            .into(),
                            translation: translation.into(),
                            rotation: rotation.into(),
                            cam_translation: cam_translation.into(),
                            cam_rotation: cam_rotation.into(),
                        };

                        Arc::new(self.uniform_buffer.next(uniform_data).unwrap())
                    };
                    let frag_uniform_buffer_subbuffer = {
                        let lights = scene.lights.lock().unwrap();

                        for (i, light) in lights.iter().enumerate() {
                            let rotation = {
                                let rotation = light.transform.rotation.lock().unwrap();

                                Matrix4::from_angle_x(Rad(rotation.x))
                                    * Matrix4::from_angle_y(Rad(rotation.y))
                                    * Matrix4::from_angle_z(Rad(rotation.z))
                            };

                            self.lights_array[i] = fragment::ty::Light {
                                position: (*light.transform.position.lock().unwrap())
                                    .into(),
                                rotation: rotation.into(),
                                color: (*light.color.lock().unwrap()).into(),
                                directional: *light.directional.lock().unwrap() as u32,
                                intensity: *light.intensity.lock().unwrap(),
                                cutoff: *light.cutoff.lock().unwrap(),
                                outer_cutoff: *light.outer_cutoff.lock().unwrap(),
                                attenuation: *light.attenuation.lock().unwrap(),
                                _dummy0: [0; 4],
                                _dummy1: [0; 12],
                            };
                        }

                        let material = model.material.lock().unwrap();
                        let uniform_data = fragment::ty::Data {
                            color: (*model.color.lock().unwrap()).into(),
                            ambient: *material.ambient.lock().unwrap(),
                            diff_strength: *material.diff_strength.lock().unwrap(),
                            spec_strength: *material.spec_strength.lock().unwrap(),
                            spec_power: *material.spec_power.lock().unwrap(),
                            lights: fragment::ty::LightArray {
                                len: lights.len() as u32,
                                array: self.lights_array,
                                _dummy0: [0; 12],
                            },
                        };
                        Arc::new(self.frag_uniform_buffer.next(uniform_data).unwrap())
                    };
                    let set_layout =
                        pipeline.layout().descriptor_set_layouts().get(0).unwrap();
                    let mut set_builder =
                        PersistentDescriptorSet::start(set_layout.clone());
                    let texture = model.texture.lock().unwrap();

                    set_builder
                        .add_buffer(uniform_buffer_subbuffer)
                        .unwrap()
                        .add_sampled_image(
                            texture.image.clone(),
                            texture.sampler.clone(),
                        )
                        .unwrap()
                        .add_buffer(frag_uniform_buffer_subbuffer)
                        .unwrap();

                    let set = Arc::new(set_builder.build().unwrap());

                    if suboptimal {
                        *recreate_swapchain = true;
                    }

                    let mesh = model.mesh.lock().unwrap();
                    let normal_buffer = CpuAccessibleBuffer::from_iter(
                        engine.device.clone(),
                        BufferUsage::all(),
                        false,
                        mesh.normals.iter().cloned(),
                    )
                    .unwrap();
                    let vertex_buffer = CpuAccessibleBuffer::from_iter(
                        engine.device.clone(),
                        BufferUsage::all(),
                        false,
                        mesh.vertices.iter().cloned(),
                    )
                    .unwrap();
                    let index_buffer = CpuAccessibleBuffer::from_iter(
                        engine.device.clone(),
                        BufferUsage::all(),
                        false,
                        mesh.indices.iter().cloned(),
                    )
                    .unwrap();

                    builder
                        .bind_descriptor_sets(
                            PipelineBindPoint::Graphics,
                            pipeline.layout().clone(),
                            0,
                            set.clone(),
                        )
                        .bind_vertex_buffers(
                            0,
                            (vertex_buffer.clone(), normal_buffer.clone()),
                        )
                        .bind_index_buffer(index_buffer.clone())
                        .draw_indexed(index_buffer.len() as u32, 1, 0, 0, 0)
                        .unwrap();
                }
            }
        }

        builder.end_render_pass().unwrap();

        let command_buffer = builder.build().unwrap();
        let future = previous_frame_end
            .take()
            .unwrap()
            .join(acquire_future)
            .then_execute(engine.queue.clone(), command_buffer)
            .unwrap()
            .then_swapchain_present(engine.queue.clone(), swapchain.clone(), image_num)
            .then_signal_fence_and_flush();

        match future {
            Ok(future) => {
                *previous_frame_end = Some(future.boxed());
            }
            Err(FlushError::OutOfDate) => {
                *recreate_swapchain = true;
                *previous_frame_end = Some(sync::now(engine.device.clone()).boxed());
            }
            Err(e) => {
                println!("Failed to flush future: {:?}", e);

                *previous_frame_end = Some(sync::now(engine.device.clone()).boxed());
            }
        }
    }

    fn vertex_entry_point(&self) -> GraphicsEntryPoint {
        self.vertex.main_entry_point()
    }

    fn fragment_entry_point(&self) -> GraphicsEntryPoint {
        self.fragment.main_entry_point()
    }
}
